# Diagram 14 — Evidence Bundle

The evidence bundle is the ground truth for all PASS claims in Stillwater. It is
an artifact-first system: evidence is produced during development, not assembled
afterward. The bundle is cumulative — each higher rung requires all files from
lower rungs plus additional evidence.

"PASS only with executable evidence — not forecasts, not prose confidence."

---

## Evidence Bundle Structure

```mermaid
flowchart TD
    BUNDLE(["Evidence Bundle\nevidence/ directory"])

    BUNDLE --> CORE["CORE FILES (required for ALL rungs)"]
    BUNDLE --> R274_FILES["RUNG 274177+ FILES"]
    BUNDLE --> R65537_FILES["RUNG 65537 FILES"]
    BUNDLE --> OPTIONAL_FILES["OPTIONAL FILES (recommended)"]

    subgraph CORE["CORE FILES — Rung 641 Minimum"]
        PLAN_JSON["plan.json\n\nRequired fields:\n- rung_target: int (641 | 274177 | 65537)\n- task_family: str\n- files_changed: list\n- goal: str\n- constraints: str"]
        TESTS_JSON["tests.json\n\nRequired fields:\n- test_command: str (e.g. 'pytest tests/')\n- exit_code: int (must be 0)\n- pass_count: int (must be > 0)\n- fail_count: int (must be 0)\n\nOptional:\n- pass (alias for pass_count)\n- failed (alias for fail_count)"]
        REPRO_RED["repro_red.log\n\nTest run BEFORE the patch\n(proves the bug existed)\nexit_code ≠ 0\n\nRed-green gate: required for\nbug fixes and features\nclaiming rung 641+"]
        REPRO_GREEN["repro_green.log\n\nTest run AFTER the patch\n(proves the fix works)\nexit_code == 0\n\nMust be same test command\nas repro_red.log"]
    end

    subgraph R274_FILES["RUNG 274177 ADDITIONAL"]
        BH_TXT["behavior_hash.txt\n\nJSON format:\n{\n  'seed_42': '<64-char SHA-256>',\n  'seed_137': '<64-char SHA-256>',\n  'seed_9001': '<64-char SHA-256>'\n}\n\nAll 3 hashes MUST agree\n(3-seed consensus)\n\nGenerated by:\nRungValidator.compute_behavior_hash()\nnormalization: split → strip → filter empty\n→ sort lines → prepend seed → SHA-256"]
    end

    subgraph R65537_FILES["RUNG 65537 ADDITIONAL"]
        SEC_SCAN["security_scan.json\n\nRequired fields:\n- status: 'PASS' (exact string match)\n\nOther fields allowed\n(scanner-specific output)\n\nStatus 'PASS' is the only gate;\nscanner output is supplementary"]
    end

    subgraph OPTIONAL_FILES["OPTIONAL FILES (Store submission recommended)"]
        GLOW_JSON["glow_score.json\n\nFields:\n- G: 0–25 (Growth)\n- L: 0–25 (Learning)\n- O: 0–25 (Output)\n- W: 0–25 (Wins)\n- total: G+L+O+W (0–100)\n- pace: warrior|master|steady|learning\n- northstar_metric_advanced: str\n- session_date: ISO8601\n\nEnables GLOW-certified badge\nin Stillwater Store"]
        FORECAST_MEMO["FORECAST_MEMO.json\n(Planner agent output)\n\nDREAM + FORECAST + DECIDE\nLane C evidence only\n(cannot claim PASS on its own)"]
        SKEPTIC_VERDICT["SKEPTIC_VERDICT.json\n(Skeptic agent output)\n\nRequired for rung 65537\nwhen orchestration is claimed"]
    end

    classDef coreNode fill:#2c4f8c,color:#fff,stroke:#1a3060
    classDef r274Node fill:#4a3d6b,color:#e0d4ff,stroke:#2e2345
    classDef r65537Node fill:#1a7a4a,color:#fff,stroke:#0f4f2f
    classDef optionalNode fill:#1e2d40,color:#cdd9e5,stroke:#4a6fa5
    class PLAN_JSON,TESTS_JSON,REPRO_RED,REPRO_GREEN coreNode
    class BH_TXT r274Node
    class SEC_SCAN r65537Node
    class GLOW_JSON,FORECAST_MEMO,SKEPTIC_VERDICT optionalNode
```

---

## How Evidence Is Produced During Development

```mermaid
flowchart TD
    TASK([Task Begins]) --> INTENT

    subgraph INTENT["1. Intent Ledger (plan.json)"]
        IL1["Author writes plan.json:\n- goal: what we're building\n- constraints: time/scope/safety\n- rung_target: 641 | 274177 | 65537\n- task_family: bug-fix | feature | refactor\n- files_changed: list of files to touch"]
        IL2["Written BEFORE any code changes\n(captures pre-commit intent)"]
        IL1 --- IL2
    end

    INTENT --> RED_PHASE

    subgraph RED_PHASE["2. Red Phase (repro_red.log)"]
        RP1["Write failing test\n(proves the problem exists)"]
        RP2["Run test suite:\npytest tests/ -v"]
        RP3["Capture output → repro_red.log\nexit_code ≠ 0\nThis is the RED state"]
        RP1 --> RP2 --> RP3
    end

    RED_PHASE --> PATCH

    subgraph PATCH["3. Patch (code changes)"]
        PA1["Implement fix or feature\n(the actual code work)"]
        PA2["Produce PATCH_DIFF\ngit diff HEAD > PATCH.diff"]
        PA1 --> PA2
    end

    PATCH --> GREEN_PHASE

    subgraph GREEN_PHASE["4. Green Phase (tests.json + repro_green.log)"]
        GP1["Run full test suite:\npytest tests/ -v"]
        GP2["Assert:\n- exit_code == 0\n- pass_count > 0\n- fail_count == 0"]
        GP3["Capture output → repro_green.log"]
        GP4["Write tests.json:\n{\n  'test_command': 'pytest tests/ -v',\n  'exit_code': 0,\n  'pass_count': N,\n  'fail_count': 0\n}"]
        GP1 --> GP2 --> GP3 --> GP4
    end

    GREEN_PHASE --> BEHAVIOR_HASH

    subgraph BEHAVIOR_HASH["5. Behavior Hash (behavior_hash.txt) — rung 274177+"]
        BH1["Run test suite 3 times\nwith seeds 42, 137, 9001"]
        BH2["For each run:\n1. Split output into lines\n2. Strip whitespace\n3. Filter empty lines\n4. Sort lines\n5. Prepend 'seed={N}'\n6. SHA-256 encode"]
        BH3["Assert all 3 hashes agree\n(3-seed consensus)"]
        BH4["Write behavior_hash.txt:\n{\n  'seed_42': '<sha256>',\n  'seed_137': '<sha256>',\n  'seed_9001': '<sha256>'\n}"]
        BH1 --> BH2 --> BH3 --> BH4
    end

    BEHAVIOR_HASH --> SEC_SCAN

    subgraph SEC_SCAN["6. Security Scan (security_scan.json) — rung 65537"]
        SS1["Run security scanner\n(e.g. bandit, semgrep, custom)"]
        SS2["Assert no critical vulnerabilities"]
        SS3["Write security_scan.json:\n{\n  'status': 'PASS',\n  ... scanner output\n}"]
        SS1 --> SS2 --> SS3
    end

    SEC_SCAN --> VALIDATE

    subgraph VALIDATE["7. Validation (RungValidator)"]
        VL1["RungValidator.verify_evidence(\n  evidence_dir=Path('evidence/'),\n  rung_target=641|274177|65537\n)"]
        VL2{Returns?}
        VL3(["VALID\nSafe to submit to Store"])
        VL4(["INVALID\nFix errors and re-run"])
        VL1 --> VL2
        VL2 -- VALID --> VL3
        VL2 -- INVALID --> VL4
    end

    classDef passNode fill:#1a7a4a,color:#fff,stroke:#0f4f2f,font-weight:bold
    classDef blockedNode fill:#9b2335,color:#fff,stroke:#6b1520,font-weight:bold
    classDef phaseNode fill:#2c4f8c,color:#fff,stroke:#1a3060
    class VL3 passNode
    class VL4 blockedNode
```

---

## Evidence Verification Flow (RungValidator)

```mermaid
flowchart TD
    SUBMIT_ATTEMPT([Submission attempt\nto Stillwater Store]) --> CLIENT_GATE

    subgraph CLIENT_GATE["Client-Side Gate (RungValidator — before HTTP request)"]
        CG1["verify_evidence(\n  evidence_dir,\n  rung_target\n)"]
        GATE1{"rung_target in\n{641, 274177, 65537}?"}
        GATE2{"evidence_dir\nexists and is dir?"}
        GATE3{"all required files\npresent?"}
        GATE4{"all JSON files\nvalid JSON?"}
        GATE5{"plan.json has:\nrung_target, task_family,\nfiles_changed?"}
        GATE6{"tests.json has:\ntest_command, exit_code?"}
        GATE7{"behavior_hash.txt has\nseed_42, seed_137,\nseed_9001?\n(if rung ≥ 274177)"}
        GATE8{"3-seed consensus:\nall hashes equal?"}
        INVALID([INVALID\ndo not submit])
        VALID_641(["VALID at rung 641\nSubmit to Store"])
        GATE1 -- NO --> INVALID
        GATE1 -- YES --> GATE2
        GATE2 -- NO --> INVALID
        GATE2 -- YES --> GATE3
        GATE3 -- NO --> INVALID
        GATE3 -- YES --> GATE4
        GATE4 -- NO --> INVALID
        GATE4 -- YES --> GATE5
        GATE5 -- NO --> INVALID
        GATE5 -- YES --> GATE6
        GATE6 -- NO --> INVALID
        GATE6 -- YES --> VALID_641
        VALID_641 --> GATE7
        GATE7 -- NO --> INVALID
        GATE7 -- YES --> GATE8
        GATE8 -- MISMATCH --> INVALID
        GATE8 -- AGREE --> VALID_274(["VALID at rung 274177"])
    end

    VALID_274 --> STORE_CHECK

    subgraph STORE_CHECK["Store-Side Check (server auto-screen)"]
        SC1["Content safety\n(no credentials, no spam)"]
        SC2["Format validation\n(QUICK LOAD block, FSM present)"]
        SC3["GLOW score validation\n(if included: G+L+O+W == total)"]
        SC1 --> SC2 --> SC3
    end

    classDef passNode fill:#1a7a4a,color:#fff,stroke:#0f4f2f,font-weight:bold
    classDef blockedNode fill:#9b2335,color:#fff,stroke:#6b1520,font-weight:bold
    classDef gateNode fill:#2c4f8c,color:#fff,stroke:#1a3060
    class VALID_641,VALID_274 passNode
    class INVALID blockedNode
    class GATE1,GATE2,GATE3,GATE4,GATE5,GATE6,GATE7,GATE8 gateNode
```

---

## Evidence Lane Classification

```mermaid
flowchart TD
    LANE_A["Lane A — Hard Fact\n(executable evidence)\n\nExamples:\n- tests.json (exit_code=0)\n- repro_red.log (test fails)\n- repro_green.log (test passes)\n- behavior_hash.txt (3-seed consensus)\n- security_scan.json (status=PASS)\n- git log (commit hash)\n- SHA-256 of artifact\n\nCan claim PASS at declared rung\nRequired for GREEN verdict in QA"]
    LANE_B["Lane B — Structural Evidence\n(schema, diagram, plan)\n\nExamples:\n- plan.json (documents intent)\n- state.mmd (state machine)\n- state.sha256 (identity proof)\n- PATCH.diff (code change)\n\nSupports PASS claim\nbut cannot stand alone"]
    LANE_C["Lane C — Heuristic / Forecast\n(analysis, prediction)\n\nExamples:\n- FORECAST_MEMO.json\n- SKEPTIC_VERDICT prose\n- README documentation\n- Code comments\n- Architectural diagrams\n  without SHA-256\n\nCannot claim PASS\nCannot upgrade status\nUseful as context only\n\nCROSS_LANE_UPGRADE is forbidden:\nLane C forecast ≠ PASS"]

    PASS_GATE(["PASS Claim\nrequires Lane A evidence\nmatching rung_target"])
    LANE_A -->|"supports"| PASS_GATE
    LANE_B -->|"supports"| PASS_GATE
    LANE_C -->|"context only\nNEVER upgrades to PASS"| PASS_GATE

    classDef laneA fill:#1a7a4a,color:#fff,stroke:#0f4f2f,font-weight:bold
    classDef laneB fill:#2c4f8c,color:#fff,stroke:#1a3060
    classDef laneC fill:#3d1a1a,color:#ffb3b3,stroke:#7a2020
    classDef passNode fill:#4a3d6b,color:#e0d4ff,stroke:#2e2345,font-weight:bold
    class LANE_A laneA
    class LANE_B laneB
    class LANE_C laneC
    class PASS_GATE passNode
```

---

## Source Files

- `/home/phuc/projects/stillwater/store/rung_validator.py` — `RungValidator`: all gate logic, `REQUIRED_EVIDENCE_FILES`, `PLAN_REQUIRED_FIELDS`, `TESTS_REQUIRED_FIELDS`, `BEHAVIOR_REQUIRED_SEEDS`, `compute_behavior_hash()`, `verify_evidence()`, `verify_rung()`, `validate_bundle()`
- `/home/phuc/projects/stillwater/skills/prime-coder.md` — evidence bundle requirements, red-green gate, Lane A/B/C classification
- `/home/phuc/projects/stillwater/skills/prime-qa.md` — evidence schema per pillar (qa_questions.json, qa_scorecard.json, qa_falsifiers.json, qa_gap_report.md)
- `/home/phuc/projects/stillwater/skills/glow-score.md` — glow_score.json schema and when O ≥ 20 requires evidence bundle path
- `/home/phuc/projects/stillwater/STORE.md` — glow_score.json schema for Store submissions

## Coverage

- All required evidence files per rung tier (plan.json, tests.json, repro_red/green.log, behavior_hash.txt, security_scan.json)
- All required JSON fields from `rung_validator.py`: `PLAN_REQUIRED_FIELDS`, `TESTS_REQUIRED_FIELDS`, `BEHAVIOR_REQUIRED_SEEDS`
- `compute_behavior_hash()` normalization algorithm (split, strip, filter, sort, prepend seed, SHA-256)
- 3-seed consensus protocol and fail-closed rule (seed mismatch → INVALID)
- Evidence production sequence during development (intent → red → patch → green → hash → scan → validate)
- `RungValidator` gate sequence (8 gates, all fail-closed)
- Lane A/B/C classification: what can claim PASS vs what is context only
- CROSS_LANE_UPGRADE forbidden state (Lane C forecast cannot claim PASS)
- Optional files: glow_score.json (Store badge), FORECAST_MEMO.json, SKEPTIC_VERDICT.json
- String sentinels "VALID"/"INVALID" (not boolean) to prevent coercion bugs
