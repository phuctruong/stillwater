{
  "model": "sonnet",
  "task_name": "task_4_dict_merge",
  "syntax_valid": true,
  "functional_pass": true,
  "quality_score": 0.75,
  "timestamp": "2026-02-24T15:15:09.782715",
  "code": "from typing import Any, Dict\n\n\ndef merge_dicts(*dicts: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Merge multiple dictionaries, with later ones overriding earlier ones on key conflicts.\n\n    Args:\n        *dicts: Variable number of dictionaries to merge. None values are skipped.\n\n    Returns:\n        A new dictionary containing all key-value pairs from the inputs.\n\n    Raises:\n        TypeError: If any non-None argument is not a dictionary.\n    \"\"\"\n    result: Dict[str, Any] = {}\n    for d in dicts:\n        if d is None:\n            continue\n        if not isinstance(d, dict):\n            raise TypeError(f\"Expected dict, got {type(d).__name__}\")\n        result.update(d)\n    return result\n\n\n# --- Test cases ---\n\ndef test_basic_merge():\n    assert merge_dicts({\"a\": 1}, {\"b\": 2}) == {\"a\": 1, \"b\": 2}\n\ndef test_override():\n    assert merge_dicts({\"a\": 1}, {\"a\": 2}) == {\"a\": 2}\n\ndef test_three_dicts():\n    assert merge_dicts({\"a\": 1}, {\"b\": 2}, {\"c\": 3}) == {\"a\": 1, \"b\": 2, \"c\": 3}\n\ndef test_chained_override():\n    assert merge_dicts({\"a\": 1}, {\"a\": 2}, {\"a\": 3}) == {\"a\": 3}\n\ndef test_empty_dicts():\n    assert merge_dicts({}, {}) == {}\n\ndef test_single_dict():\n    assert merge_dicts({\"a\": 1}) == {\"a\": 1}\n\ndef test_no_args():\n    assert merge_dicts() == {}\n\ndef test_none_skipped():\n    assert merge_dicts({\"a\": 1}, None, {\"b\": 2}) == {\"a\": 1, \"b\": 2}\n\ndef test_all_none():\n    assert merge_dicts(None, None) == {}\n\ndef test_none_value_in_dict():\n    assert merge_dicts({\"a\": None}, {\"b\": 2}) == {\"a\": None, \"b\": 2}\n\ndef test_override_with_none_value():\n    assert merge_dicts({\"a\": 1}, {\"a\": None}) == {\"a\": None}\n\ndef test_nested_dicts():\n    result = merge_dicts({\"a\": {\"x\": 1}}, {\"a\": {\"y\": 2}})\n    assert result == {\"a\": {\"y\": 2}}  # shallow override, not deep merge\n\ndef test_mixed_key_types():\n    assert merge_dicts({1: \"a\"}, {2: \"b\"}) == {1: \"a\", 2: \"b\"}\n\ndef test_invalid_argument():\n    try:\n        merge_dicts({\"a\": 1}, \"not a dict\")\n        assert False, \"Should have raised TypeError\"\n    except TypeError as e:\n        assert \"Expected dict, got str\" in str(e)\n\ndef test_invalid_argument_int():\n    try:\n        merge_dicts(42)\n        assert False, \"Should have raised TypeError\"\n    except TypeError:\n        pass\n\ndef test_original_unmodified():\n    d1 = {\"a\": 1}\n    d2 = {\"b\": 2}\n    result = merge_dicts(d1, d2)\n    assert d1 == {\"a\": 1}\n    assert d2 == {\"b\": 2}\n    assert result is not d1 and result is not d2\n\n\nif __name__ == \"__main__\":\n    for name, func in list(globals().items()):\n        if name.startswith(\"test_\") and callable(func):\n            func()\n            print(f\"  {name} passed\")\n    print(f\"\\nAll tests passed.\")",
  "baseline": true
}